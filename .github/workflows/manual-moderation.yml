name: Manual Moderation

on:
  issue_comment:
    types: [created]

permissions:
  discussions: write
  issues: write
  contents: write

jobs:
  manual-moderate:
    runs-on: ubuntu-latest
    if: contains(github.event.comment.body, '/moderate')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Process moderation commands
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = context.payload.comment.body;
            const commenter = context.payload.comment.user.login;
            
            // Check if user has moderation permissions (repo collaborator)
            try {
              const { data: collaborator } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: commenter
              });
              
              if (!['admin', 'write'].includes(collaborator.permission)) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `âŒ @${commenter} You don't have permission to use moderation commands.`
                });
                return;
              }
            } catch (error) {
              console.log(`Failed to check permissions for ${commenter}: ${error.message}`);
              return;
            }
            
            // Parse moderation commands
            const commands = {
              '/moderate block': /\/moderate block @?(\w+)/i,
              '/moderate unblock': /\/moderate unblock @?(\w+)/i,
              '/moderate trust': /\/moderate trust @?(\w+)/i,
              '/moderate untrust': /\/moderate untrust @?(\w+)/i,
              '/moderate ban-word': /\/moderate ban-word (.+)/i,
              '/moderate unban-word': /\/moderate unban-word (.+)/i,
              '/moderate status': /\/moderate status/i
            };
            
            let actionTaken = false;
            
            // Block user
            if (commands['/moderate block'].test(comment)) {
              const match = comment.match(commands['/moderate block']);
              const username = match[1].toLowerCase();
              
              const blockedUsers = fs.readFileSync('.banned/blocked-users.txt', 'utf-8');
              if (!blockedUsers.includes(username)) {
                fs.appendFileSync('.banned/blocked-users.txt', `\\n${username}`);
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `âœ… User @${username} has been blocked by @${commenter}.`
                });
                actionTaken = true;
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `â„¹ï¸ User @${username} is already blocked.`
                });
              }
            }
            
            // Unblock user
            if (commands['/moderate unblock'].test(comment)) {
              const match = comment.match(commands['/moderate unblock']);
              const username = match[1].toLowerCase();
              
              const blockedUsers = fs.readFileSync('.banned/blocked-users.txt', 'utf-8');
              const newBlockedUsers = blockedUsers.split('\\n')
                .filter(user => user.trim().toLowerCase() !== username)
                .join('\\n');
              
              fs.writeFileSync('.banned/blocked-users.txt', newBlockedUsers);
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âœ… User @${username} has been unblocked by @${commenter}.`
              });
              actionTaken = true;
            }
            
            // Trust user
            if (commands['/moderate trust'].test(comment)) {
              const match = comment.match(commands['/moderate trust']);
              const username = match[1].toLowerCase();
              
              const trustedUsers = fs.readFileSync('.banned/trusted-users.txt', 'utf-8');
              if (!trustedUsers.includes(username)) {
                fs.appendFileSync('.banned/trusted-users.txt', `\\n${username}`);
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `âœ… User @${username} has been added to trusted users by @${commenter}.`
                });
                actionTaken = true;
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `â„¹ï¸ User @${username} is already trusted.`
                });
              }
            }
            
            // Untrust user
            if (commands['/moderate untrust'].test(comment)) {
              const match = comment.match(commands['/moderate untrust']);
              const username = match[1].toLowerCase();
              
              const trustedUsers = fs.readFileSync('.banned/trusted-users.txt', 'utf-8');
              const newTrustedUsers = trustedUsers.split('\\n')
                .filter(user => user.trim().toLowerCase() !== username)
                .join('\\n');
              
              fs.writeFileSync('.banned/trusted-users.txt', newTrustedUsers);
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âœ… User @${username} has been removed from trusted users by @${commenter}.`
              });
              actionTaken = true;
            }
            
            // Ban word
            if (commands['/moderate ban-word'].test(comment)) {
              const match = comment.match(commands['/moderate ban-word']);
              const word = match[1].toLowerCase().trim();
              
              const bannedWords = fs.readFileSync('.banned/banned-words.txt', 'utf-8');
              if (!bannedWords.includes(word)) {
                fs.appendFileSync('.banned/banned-words.txt', `\\n${word}`);
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `âœ… Word "${word}" has been banned by @${commenter}.`
                });
                actionTaken = true;
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `â„¹ï¸ Word "${word}" is already banned.`
                });
              }
            }
            
            // Unban word
            if (commands['/moderate unban-word'].test(comment)) {
              const match = comment.match(commands['/moderate unban-word']);
              const word = match[1].toLowerCase().trim();
              
              const bannedWords = fs.readFileSync('.banned/banned-words.txt', 'utf-8');
              const newBannedWords = bannedWords.split('\\n')
                .filter(w => w.trim().toLowerCase() !== word)
                .join('\\n');
              
              fs.writeFileSync('.banned/banned-words.txt', newBannedWords);
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âœ… Word "${word}" has been unbanned by @${commenter}.`
              });
              actionTaken = true;
            }
            
            // Show status
            if (commands['/moderate status'].test(comment)) {
              const bannedWords = fs.readFileSync('.banned/banned-words.txt', 'utf-8').split('\\n').filter(Boolean);
              const blockedUsers = fs.readFileSync('.banned/blocked-users.txt', 'utf-8').split('\\n').filter(Boolean).filter(u => !u.startsWith('#'));
              const trustedUsers = fs.readFileSync('.banned/trusted-users.txt', 'utf-8').split('\\n').filter(Boolean).filter(u => !u.startsWith('#'));
              
              const statusMessage = `## ðŸ“Š Moderation Status\\n\\n` +
                `**Banned Words**: ${bannedWords.length}\\n` +
                `**Blocked Users**: ${blockedUsers.length}\\n` +
                `**Trusted Users**: ${trustedUsers.length}\\n\\n` +
                `### Blocked Users:\\n${blockedUsers.length > 0 ? blockedUsers.map(u => \`- @\${u}\`).join('\\n') : '_None_'}\\n\\n` +
                `### Trusted Users:\\n${trustedUsers.length > 0 ? trustedUsers.map(u => \`- @\${u}\`).join('\\n') : '_None_'}`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: statusMessage
              });
            }
            
            // Commit changes if any action was taken
            if (actionTaken) {
              try {
                await github.rest.repos.createOrUpdateFileContents({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: '.banned/blocked-users.txt',
                  message: `Update moderation lists via command from @${commenter}`,
                  content: Buffer.from(fs.readFileSync('.banned/blocked-users.txt')).toString('base64'),
                  sha: (await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: '.banned/blocked-users.txt'
                  })).data.sha
                });
                
                await github.rest.repos.createOrUpdateFileContents({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: '.banned/trusted-users.txt',
                  message: `Update moderation lists via command from @${commenter}`,
                  content: Buffer.from(fs.readFileSync('.banned/trusted-users.txt')).toString('base64'),
                  sha: (await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: '.banned/trusted-users.txt'
                  })).data.sha
                });
                
                await github.rest.repos.createOrUpdateFileContents({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: '.banned/banned-words.txt',
                  message: `Update moderation lists via command from @${commenter}`,
                  content: Buffer.from(fs.readFileSync('.banned/banned-words.txt')).toString('base64'),
                  sha: (await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: '.banned/banned-words.txt'
                  })).data.sha
                });
              } catch (error) {
                console.log(`Failed to commit changes: ${error.message}`);
              }
            }